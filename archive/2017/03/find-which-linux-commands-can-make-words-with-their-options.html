<!DOCTYPE html>
<html  lang="en">
	<head>
		<meta charset="utf-8"/> 
		<meta name="viewport" content="width=device-width, initial-scale=1.0">
		<title>Find which Linux commands can make words out of their options</title>
		<meta name="robots" content="index, follow">
		<meta name="description" content="Blog for Grayson Kent - Linux,Security,Networking,Virtualization">
	    <meta name="author" content="Grayson Kent" />
		<script type="text/javascript" src="../../js/SyntaxHighlight/shCore.js"></script>
		<script type="text/javascript" src="../../js/SyntaxHighlight/Plain.js"></script>
		<script type="text/javascript" src="../../js/SyntaxHighlight/Bash.js"></script>
		<link href="../../css/shThemeDefault.css" rel="stylesheet" type="text/css" />
		<link href="../../css/shCore.css" rel="stylesheet" type="text/css" />
		<link href="../../css/posts.css" rel="stylesheet" type="text/css" />
		<link rel="icon" type="image/png" href="../../../images/tux.png">
	</head>
		<ul id="header">
			<li class="navbar"><a href="mailto:grayson@linux.com" class="button">Contact</a></li>
			<li class="navbar"><a href="../../../about.html" class="button">About</a></li>
			<li class="navbar"><a href="../../index.html" class="button">Archive</a></li>
			<li class="navbar"><a href="../../../index.html" class="button">Home</a></li>
		</ul>
			<h2>Find which Linux commands can make words out of their options <span class="date">3/27/2017</span></h2>
				<p>I noticed that I always prefer using commands with options that spell out common words like <span class="highlight">ps -elf</span> or <span class="highlight">ls -cat</span> as they are easier to remember, so I decided to write a script to find out where other instances like this can happen:</p>
					<pre class="brush: bash">
#!/bin/bash

# Pull in a list of common Linux commands
commandList=( $( 
  curl 'http://www.thegeekstuff.com/2010/11/50-linux-commands/' 2> /dev/null \
    | grep -o '&#60;h3&#62;\([0-9].*[a-z][a-z][a-z].*\)&#60;/h3&#62;' \
    | awk '{ print $(NF-2) }' \
    | sed -nr '/rm|wget|less|shutdown|&#60;h3&#62;/!p'
) ); 

# Pipe successful "$command -$option" pairs to 'an' to generate anagrams 
for command in ${commandList[@]} ; do 
	(for option in {a..z} ; do
		timeout -k 5 5 "$command" -"$option" > /dev/null 2>&1;
			if (($? == 0)); then
				printf "$option" | tr -d '\n'
			else
        			:
			fi
	done) | xargs an -w -d saneWordlist -m 3 2> /dev/null \
          | sed 's/^/\ '$command' -/' >> commandOptions.log
done				
</pre>				
				<p>Ugly, and not something I would ever put my name on professionally, but it gets the job done. It produces over 12,000 <i>command -word</i> combinations with the 50 sample input Linux commands. Here are some of my favorites it found:</p>
				<pre class="brush: bash">
ls -afro
ls -grinch
ls -algorithm
ls -akimbo
ls -albino
ls -angst
ls -badmouth
ls -calming
ls -flamingos
ls -frogman
ls -gambit
ls -groans
ls -gulps
ls -hacking
ls -hustling
ls -liar
ls -nachos
ls -obfuscating
ls -prodigal
ps -centaur
ps -gnu
ps -manure
ps -nuclear
free -tomb
free -bolt
df -milk
df -ham
mount -swirl
uname -savior
uname -prison
uname -pain
whereis -bums
whereis -bus
</pre>
<p>So I guess the lesson here is that <span class="highlight">ls</span> can take pretty much any option.</p>
<h2>How it works</h2>
				<p>It starts by pulling in a blog post of example Linux commands because I am too lazy to write them all out:</p>
				<pre class="brush: bash">

  curl 'http://www.thegeekstuff.com/2010/11/50-linux-commands/' 2> /dev/null 
</pre>
			<p>After it has that input, it searches for the tag that contains the titles of the command (&#60;h3&#62;) with <span class="highlight">grep</span>, then uses <span class="highlight">awk</span> to delimit the fields and print the next to last one where our command is. <span class="highlight">sed</span> then throws out any line containing commands we don't want like <span class="highlight">rm</span>:</p>
<pre class="brush: bash">
     grep -o '&#60;h3&#62;\([0-9].*[a-z][a-z][a-z].*\)&#60;/h3&#62;' \
    | awk '{ print $(NF-2) }' \
    | sed -nr '/rm|wget|less|shutdown|&#60;h3&#62;/!p'
</pre>
		<p>For example, this pulls out just the command <span class="highlight">tar</span> from:</p>
<pre class="brush: plain">&#60;h3&#62;1. tar command examples&#60;/h3&#62;</pre>
		<p>Each of the 50 example commands are now stored in an array called <span class ="highlight">commandList</span> like so:
<pre class="brush: bash">
commandList=( $( 
  curl 'http://www.thegeekstuff.com/2010/11/50-linux-commands/' 2> /dev/null \
    | grep -o '&#60;h3&#62;\([0-9].*[a-z][a-z][a-z].*\)&#60;/h3&#62;' \
    | awk '{ print $(NF-2) }' \
    | sed -nr '/rm|wget|less|shutdown|&#60;h3&#62;/!p'
) ); 
</pre>
				<p>Then it iterates through the <span class="highlight">commandList</span> array and tries each command with every letter as an option. It has 5 seconds to run before SIGKILL is sent:</p>
				
<pre class="brush: bash">for command in ${commandList[@]} ; do 
	(for option in {a..z} ; do
		timeout -k 5 5 "$command" -"$option" > /dev/null 2>&1;				
</pre>				
				
				<p>If it exits successfully, loop through and output successful options without a new line character. Otherwise, do nothing:</p>
<pre class="brush: bash">  
			if (($? == 0)); then
				printf "$option" | tr -d '\n'
			else
        			:
			fi
</pre>
				<p>At the end of that, output successful options to <span class="highlight">an</span>, a tool for generating anagrams. Allow only words over 3 characters and use a custom dictionary I made:</p>
					<pre class="brush: bash">
xargs an -w -d saneWordlist -m 3 2> /dev/null 						
</pre>
		<p>Here is how I made my custom dictionary:</p>
					<pre class="brush: bash">grep -v '[[:punct:]]' /usr/share/dict/words | sed  's/Ã©/e/g' > saneWordlist
</pre>
		<p>After <span class="highlight">an</span> generates anagrams, let <span class="highlight">sed</span> insert the command name at the start of the anagram list so we can identify who it belongs to and append to a file:</p>
					<pre class="brush: bash">
sed 's/^/\ '$command' -/' >> commandOptions.log								
</pre>

	<p>As I said earlier, this is an ugly program. It is not made to exhaustively find each command option, but rather generate a good list to look through.</p>
<h3>Areas for Improvement</h3>
	<p>- I don't look for capitalized options because I didn't want to deal with trying to match up words that start with that letter.</p>
	<p>- If I did it again, I would have written this in Python just for the array options.</p>	
	<p>- I abused <span class="highlight">sed</span> and <span class="highlight">awk</span> in places where I should have just used a more robust regex match<p>
	<p>- If you wanted to play Russian roulette with your computer, you could switch out the command from <span class="highlight">commandList</span> with <span class="highlight">compgen -cb</span>. I would write a log file to a remote location and add in traps in case one of the commands brought down your machine.</p> 
	<p>- Lastly, this script is inherently flawed as I am relying on exit codes that are not at all consistent and just hoping the devs used <span class="highlight">0</span> to indicate success. Commands like <span class="highlight">vim</span> and <span class="highlight">passwd</span> can't even be killed reliably by GNU's <span class="highlight">timeout</span> without affecting the exit code. I don't currently know a better workaround that doesn't require a large amount of time for marginally better results. Initially I was grepping through man pages looking for flags, but that leads to the same inconsistency issue as exit codes:</p>
						<pre class="brush: bash">
man --where --all "$command" > /dev/null 2>&1 
if (($? == 0)); then
	mapfile -t commandOptions &#60; &#60;(
	printf "$i-" && man $i \
	| sed -ne 's/.*\(-[A-Za-z],\).*/\1/p' \
	| sort -u \
	| tr -d ',-' \
	| tr -d '\n')					
</pre>
		<div class="footer"/>	
	<script type="text/javascript">SyntaxHighlighter.all()</script>
</html>